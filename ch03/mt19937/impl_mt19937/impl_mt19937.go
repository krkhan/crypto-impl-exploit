package impl_mt19937

import (
	"time"
)

const (
	W uint32 = 32
	N uint32 = 624
	M uint32 = 397
	R uint32 = 31

	A uint32 = 0x9908B0DF
	F uint32 = 1812433253

	U uint32 = 11
	D uint32 = 0xFFFFFFFF

	S uint32 = 7
	B uint32 = 0x9D2C5680

	T uint32 = 15
	C uint32 = 0xEFC60000

	L uint32 = 18

	LowerMask uint32 = 0x7FFFFFFF
	UpperMask uint32 = 0x80000000
)

type MT19937 struct {
	Seeded bool
	Index  uint32
	State  [N]uint32
}

func NewMT19937() *MT19937 {
	return &MT19937{
		Index: 0,
		State: [N]uint32{},
	}
}

func (mt *MT19937) Seed(seed uint32) {
	mt.Index = 0
	mt.State[0] = seed

	for i := uint32(1); i < N; i++ {
		mt.State[i] = (F*(mt.State[i-1]^(mt.State[i-1]>>(W-2))) + i)
	}

	mt.Seeded = true
}

func (mt *MT19937) Generate() uint32 {
	if mt.Index == 0 {
		if !mt.Seeded {
			mt.Seed(uint32(time.Now().Unix()))
		}
		mt.twist()
	}

	y := temper(mt.State[mt.Index])

	mt.Index = (mt.Index + 1) % N

	return y
}

func (mt *MT19937) twist() {
	for i := uint32(0); i < N; i++ {
		x := (mt.State[i] & UpperMask) + (mt.State[(i+1)%N] & LowerMask)
		xA := x >> 1
		if x%2 == 1 {
			xA ^= A
		}
		mt.State[i] = mt.State[(i+M)%N] ^ xA
	}

	mt.Index = 0
}

func temper(y uint32) uint32 {
	y1 := y ^ (y>>U)&D
	y2 := y1 ^ (y1<<S)&B
	y3 := y2 ^ (y2<<T)&C
	y4 := y3 ^ (y3 >> L)
	return y4
}
