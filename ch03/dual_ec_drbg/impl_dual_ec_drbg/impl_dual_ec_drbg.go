package impl_dual_ec_drbg

import (
	"crypto/elliptic"
	"errors"
	"math/big"
	"time"
)

const (
	Px = "6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"
	Py = "4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"
	Qx = "c97445f45cdef9f0d3e05e1e585fc297235b82b5be8ff3efca67c59852018192"
	Qy = "b28ef557ba31dfcbdd21ac46e2a91e3c304f44cb87058ada2cb815151e610046"
)

type Point struct {
	X *big.Int
	Y *big.Int
}

func NewPoint(x, y string) (*Point, error) {
	xb, ok := new(big.Int).SetString(x, 16)
	if !ok {
		return nil, errors.New("invalid x")
	}

	yb, ok := new(big.Int).SetString(y, 16)
	if !ok {
		return nil, errors.New("invalid y")
	}

	return &Point{
		X: xb,
		Y: yb,
	}, nil
}

func (p1 *Point) Cmp(p2 *Point) bool {
	// For big.Int, a.Cmp(b) equals 0 when a == b
	return p1.X.Cmp(p2.X) == 0 && p1.Y.Cmp(p2.Y) == 0
}

type DualEcDrbg struct {
	state *big.Int
	p     *Point
	q     *Point
}

func NewDualEcDrbg(p *Point, q *Point) (*DualEcDrbg, error) {
	if p == nil {
		return nil, errors.New("invalid point p")
	}
	if q == nil {
		return nil, errors.New("invalid point q")
	}

	return &DualEcDrbg{
		state: nil,
		p:     p,
		q:     q,
	}, nil
}

func (drbg *DualEcDrbg) Seed(seed *big.Int) {
	drbg.state = seed
}

func (drbg *DualEcDrbg) Generate() []byte {
	if drbg.state == nil {
		seed := new(big.Int).SetInt64(time.Now().Unix())
		drbg.Seed(seed)
	}

	curve := elliptic.P256()
	drbg.state, _ = curve.ScalarMult(drbg.p.X, drbg.p.Y, drbg.state.Bytes())
	result, _ := curve.ScalarMult(drbg.q.X, drbg.q.Y, drbg.state.Bytes())
	resultBytes := result.Bytes()
	resultLen := len(resultBytes)

	return resultBytes[resultLen-30:]
}
