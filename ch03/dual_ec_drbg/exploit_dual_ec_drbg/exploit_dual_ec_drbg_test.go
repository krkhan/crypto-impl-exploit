package dual_ec_drbg

import (
	"bytes"
	"crypto/elliptic"
	"encoding/hex"
	"github.com/krkhan/crypto-impl-exploit/ch03/dual_ec_drbg/impl_dual_ec_drbg"
	"math/big"
	"testing"
	"time"
)

func TestBackdoorConstants(t *testing.T) {
	curve := elliptic.P256()
	p, q, d := GenerateBackdoorConstants()
	dqX, dqY := curve.ScalarMult(q.X, q.Y, d.Bytes())
	dq := &impl_dual_ec_drbg.Point{
		X: dqX,
		Y: dqY,
	}
	if !p.Cmp(dq) {
		t.Fatal("p != dq")
	}
}

func TestCalculateYCoordinate(t *testing.T) {
	x, _ := new(big.Int).SetString("6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296", 16)
	y, _ := new(big.Int).SetString("4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5", 16)
	generated_y, err := CalculateYCoordinate(x)
	if err != nil {
		t.Fatalf("error generating y: %s", err)
	}
	if y.Cmp(generated_y) != 0 {
		t.Fatalf("incorrect y, expected=%s, generated=%s", y, generated_y)
	}
}

func TestCloneDualEcDrbg(t *testing.T) {
	p, q, d := GenerateBackdoorConstants()
	drbg, err := impl_dual_ec_drbg.NewDualEcDrbg(p, q)
	if err != nil {
		t.Fatalf("error creating drbg: %s", err)
	}
	seed := new(big.Int).SetInt64(time.Now().Unix())
	drbg.Seed(seed)
	for i := 0; i < 100; i++ {
		_ = drbg.Generate()
	}
	clonedDrbg, err := CloneDualEcDrbg(drbg, p, q, d)
	if err != nil {
		t.Fatalf("error brute forcing drbg: %s", err)
	}
	for i := 0; i < 100; i++ {
		cloned := clonedDrbg.Generate()
		observed := drbg.Generate()
		if bytes.Compare(cloned, observed) != 0 {
			t.Fatalf("observed=%s, cloned=%s", hex.EncodeToString(observed), hex.EncodeToString(cloned))
		}
		if i%20 == 0 {
			t.Logf("observed=%s, cloned=%s", hex.EncodeToString(observed), hex.EncodeToString(cloned))
		}
	}
}
