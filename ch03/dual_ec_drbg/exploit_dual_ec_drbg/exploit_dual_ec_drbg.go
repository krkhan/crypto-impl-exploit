package dual_ec_drbg

import (
	"bytes"
	"crypto/elliptic"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/krkhan/crypto-impl-exploit/ch03/dual_ec_drbg/impl_dual_ec_drbg"
	"math/big"
	"math/rand"
	"time"
)

func GenerateBackdoorConstants() (*impl_dual_ec_drbg.Point, *impl_dual_ec_drbg.Point, *big.Int) {
	rnd := rand.New(rand.NewSource(time.Now().Unix()))
	curve := elliptic.P256()
	n := curve.Params().N
	d := new(big.Int)
	d.Rand(rnd, n)
	e := new(big.Int)
	e.ModInverse(d, n)
	px, py := curve.Params().Gx, curve.Params().Gy
	qx, qy := curve.ScalarMult(px, py, e.Bytes())
	return &impl_dual_ec_drbg.Point{
			X: px,
			Y: py,
		}, &impl_dual_ec_drbg.Point{
			X: qx,
			Y: qy,
		}, d
}

func CalculateYCoordinate(x *big.Int) (*big.Int, error) {
	curve := elliptic.P256()
	x_cube := new(big.Int).Exp(x, new(big.Int).SetInt64(3), curve.Params().P)
	ax := new(big.Int).Mul(new(big.Int).SetInt64(-3), x)
	x_cube_plus_ax := new(big.Int).Add(x_cube, ax)
	x_cube_plus_ax = new(big.Int).Mod(x_cube_plus_ax, curve.Params().P)
	x_cube_plus_ax_plus_b := new(big.Int).Add(x_cube_plus_ax, curve.Params().B)
	x_cube_plus_ax_plus_b = new(big.Int).Mod(x_cube_plus_ax_plus_b, curve.Params().P)
	y := new(big.Int).ModSqrt(x_cube_plus_ax_plus_b, curve.Params().P)
	if y == nil {
		return nil, errors.New("not a valid point")
	}
	y_squared := new(big.Int).Exp(y, new(big.Int).SetInt64(2), curve.Params().P)
	if y_squared.Cmp(x_cube_plus_ax_plus_b) != 0 {
		return nil, errors.New("not a valid point")
	}
	if !curve.IsOnCurve(x, y) {
		return nil, errors.New("not a valid point")
	}

	return y, nil
}

func CloneDualEcDrbg(drbg *impl_dual_ec_drbg.DualEcDrbg, p, q *impl_dual_ec_drbg.Point, d *big.Int) (*impl_dual_ec_drbg.DualEcDrbg, error) {
	observed := drbg.Generate()
	check := drbg.Generate()

	curve := elliptic.P256()
	fmt.Printf(" check: %s\n", hex.EncodeToString(check))
	for i := uint16(0); i < 0xffff; i++ {
		guess := make([]byte, 32)
		binary.BigEndian.PutUint16(guess[0:2], i)
		n := copy(guess[2:], observed)
		if n != 30 {
			return nil, errors.New("could not copy")
		}
		x := new(big.Int).SetBytes(guess)
		y, err := CalculateYCoordinate(x)
		if err != nil {
			continue
		}
		next_i, _ := curve.ScalarMult(x, y, d.Bytes())
		next_o, _ := curve.ScalarMult(q.X, q.Y, next_i.Bytes())
		next_o_len := len(next_o.Bytes())
		next_o_truncated := next_o.Bytes()[next_o_len-30:]
		fmt.Printf("next_o: %s, guess: %04X\r", hex.EncodeToString(next_o_truncated), i)
		if bytes.Compare(check, next_o_truncated) == 0 {
			cloned_drbg, err := impl_dual_ec_drbg.NewDualEcDrbg(p, q)
			if err != nil {
				continue
			}
			fmt.Printf("\n")
			cloned_drbg.Seed(next_i)
			return cloned_drbg, nil
		}
	}
	fmt.Println()
	return nil, errors.New("could not find any points")
}
