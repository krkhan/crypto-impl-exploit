package dual_ec_drbg

import (
	"bytes"
	"crypto/elliptic"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"github.com/krkhan/crypto-impl-exploit/ch03/dual_ec_drbg/impl_dual_ec_drbg"
	"math/big"
	"math/rand"
	"time"
)

func GenerateBackdoorConstants() (*impl_dual_ec_drbg.Point, *impl_dual_ec_drbg.Point, *big.Int) {
	rnd := rand.New(rand.NewSource(time.Now().Unix()))
	curve := elliptic.P256()
	n := curve.Params().N
	d := new(big.Int)
	d.Rand(rnd, n)
	e := new(big.Int)
	e.ModInverse(d, n)
	px, py := curve.Params().Gx, curve.Params().Gy
	qx, qy := curve.ScalarMult(px, py, e.Bytes())
	return &impl_dual_ec_drbg.Point{
			X: px,
			Y: py,
		}, &impl_dual_ec_drbg.Point{
			X: qx,
			Y: qy,
		}, d
}

func CalculateYCoordinate(x *big.Int) (*big.Int, error) {
	curve := elliptic.P256()
	xCube := new(big.Int).Exp(x, new(big.Int).SetInt64(3), curve.Params().P)
	ax := new(big.Int).Mul(new(big.Int).SetInt64(-3), x)
	xCubePlusAx := new(big.Int).Add(xCube, ax)
	xCubePlusAx = new(big.Int).Mod(xCubePlusAx, curve.Params().P)
	xCubePlusAxPlusB := new(big.Int).Add(xCubePlusAx, curve.Params().B)
	xCubePlusAxPlusB = new(big.Int).Mod(xCubePlusAxPlusB, curve.Params().P)
	y := new(big.Int).ModSqrt(xCubePlusAxPlusB, curve.Params().P)
	if y == nil {
		return nil, errors.New("not a valid point")
	}
	ySquared := new(big.Int).Exp(y, new(big.Int).SetInt64(2), curve.Params().P)
	if ySquared.Cmp(xCubePlusAxPlusB) != 0 {
		return nil, errors.New("not a valid point")
	}
	if !curve.IsOnCurve(x, y) {
		return nil, errors.New("not a valid point")
	}

	return y, nil
}

func CloneDualEcDrbg(drbg *impl_dual_ec_drbg.DualEcDrbg, p, q *impl_dual_ec_drbg.Point, d *big.Int) (*impl_dual_ec_drbg.DualEcDrbg, error) {
	observed := drbg.Generate()
	check := drbg.Generate()

	curve := elliptic.P256()
	fmt.Printf(" check: %s\n", hex.EncodeToString(check))
	for i := uint16(0); i < 0xffff; i++ {
		guess := make([]byte, 32)
		binary.BigEndian.PutUint16(guess[0:2], i)
		n := copy(guess[2:], observed)
		if n != 30 {
			return nil, errors.New("could not copy")
		}
		x := new(big.Int).SetBytes(guess)
		y, err := CalculateYCoordinate(x)
		if err != nil {
			continue
		}
		nextI, _ := curve.ScalarMult(x, y, d.Bytes())
		nextO, _ := curve.ScalarMult(q.X, q.Y, nextI.Bytes())
		nextOLen := len(nextO.Bytes())
		nextOTruncated := nextO.Bytes()[nextOLen-30:]
		fmt.Printf("next_o: %s, guess: %04X\r", hex.EncodeToString(nextOTruncated), i)
		if bytes.Compare(check, nextOTruncated) == 0 {
			clonedDrbg, err := impl_dual_ec_drbg.NewDualEcDrbg(p, q)
			if err != nil {
				continue
			}
			fmt.Println()
			clonedDrbg.Seed(nextI)
			return clonedDrbg, nil
		}
	}
	fmt.Println()
	return nil, errors.New("could not find any points")
}
