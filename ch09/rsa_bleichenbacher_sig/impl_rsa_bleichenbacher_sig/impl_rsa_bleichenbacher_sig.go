package impl_rsa_bleichenbacher_sig

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"fmt"
	"math/big"
)

const (
	ModulusBits = 2048
	HashAsn1Md5 = ("\x30\x20\x30\x0c\x06\x08\x2a\x86" +
		"\x48\x86\xf7\x0d\x02\x05\x05\x00\x04\x10")
	HashAsn1Sha1 = ("\x30\x21\x30\x09\x06\x05\x2b\x0e" +
		"\x03\x02\x1a\x05\x00\x04\x14")
	HashAsn1Sha256 = ("\x30\x31\x30\x0d\x06\x09\x60\x86" +
		"\x48\x01\x65\x03\x04\x02\x01\x05\x00\x04\x20")
)

type RSAKeypair struct {
	PublicKey *rsa.PublicKey
	privKey   *rsa.PrivateKey
}

func GenerateRSAKeypairWithPublicExponent3() (*RSAKeypair, error) {
	var p, q *big.Int
	var err error

	for {
		p, err = rand.Prime(rand.Reader, ModulusBits/2)
		if err != nil {
			return nil, err
		}

		q, err = rand.Prime(rand.Reader, ModulusBits/2)
		if err != nil {
			return nil, err
		}

		if p.Cmp(q) == 1 {
			p, q = q, p
		}

		qDouble := new(big.Int).Mul(q, big.NewInt(2))

		if p.Cmp(qDouble) != -1 {
			continue
		}

		modulus := new(big.Int).Mul(p, q)
		pMinus1 := new(big.Int).Sub(p, big.NewInt(1))
		qMinus1 := new(big.Int).Sub(q, big.NewInt(1))
		phi := new(big.Int).Mul(pMinus1, qMinus1)

		e := new(big.Int).SetInt64(3)
		d := new(big.Int).ModInverse(e, phi)

		if d == nil {
			continue
		}

		pubKey := rsa.PublicKey{
			N: modulus,
			E: int(e.Int64()),
		}
		privKey := &rsa.PrivateKey{
			PublicKey: pubKey,
			D:         d,
		}
		keyPair := RSAKeypair{
			PublicKey: &pubKey,
			privKey:   privKey,
		}

		return &keyPair, nil
	}
}

func VerifyPKCS1v15Insecure(pub *rsa.PublicKey, hashAlg crypto.Hash, digest []byte, sig []byte) error {
	fmt.Printf("hashAlg: %s\n", hashAlg)
	fmt.Printf("digest: 0x%X\n", digest)
	fmt.Printf("sig: 0x%X\n", sig)

	eNum := new(big.Int).SetInt64(int64(pub.E))
	sigNum := new(big.Int).SetBytes(sig)
	sigExpE := new(big.Int).Exp(sigNum, eNum, pub.N)
	sigExpEBytes := sigExpE.Bytes()

	sigCleartext := make([]byte, ModulusBits/8)
	offset := len(sigCleartext) - len(sigExpEBytes)
	for i := offset; i < len(sigCleartext); i++ {
		sigCleartext[i] = sigExpEBytes[i-offset]
	}
	fmt.Printf("sigCleartext: 0x%X\n", sigCleartext)

	if bytes.Compare(sigCleartext[0:2], []byte{0x00, 0x01}) != 0 {
		return fmt.Errorf("verification failed: header mismatch")
	}

	sepIdx := bytes.IndexByte(sigCleartext[2:], byte(0x00)) + 3

	var hashAsn1Identifier []byte
	switch hashAlg {
	case crypto.MD5:
		hashAsn1Identifier = []byte(HashAsn1Md5)
	case crypto.SHA1:
		hashAsn1Identifier = []byte(HashAsn1Sha1)
	case crypto.SHA256:
		hashAsn1Identifier = []byte(HashAsn1Sha256)
	}

	if bytes.Compare(sigCleartext[sepIdx:sepIdx+len(hashAsn1Identifier)], hashAsn1Identifier) != 0 {
		return fmt.Errorf("verification failed: asn1 identifier mismatch")
	}

	digestIdx := sepIdx + len(hashAsn1Identifier)
	if bytes.Compare(sigCleartext[digestIdx:digestIdx+len(digest)], digest) != 0 {
		return fmt.Errorf("verification failed: digest mismatch")
	}

	if len(sigCleartext) > digestIdx+len(digest) {
		return fmt.Errorf("verification failed: trailing bytes")
	}

	return nil
}
