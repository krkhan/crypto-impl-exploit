package exploit_rsa_bleichenbacher_sig

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
	"testing"

	"github.com/krkhan/crypto-impl-exploit/ch09/rsa_bleichenbacher_sig/impl_rsa_bleichenbacher_sig"
)

func TestCubeRootPrefix(t *testing.T) {
	randomN := make([]byte, 24)
	_, err := rand.Read(randomN)
	if err != nil {
		t.Fatalf("error generating random n: %s", err)
	}
	nPrefixBytesToMatch := 4
	randomNum := new(big.Int).SetBytes(randomN)
	t.Logf("randomN: 0x[%X]%x", randomN[:nPrefixBytesToMatch], randomN[nPrefixBytesToMatch:])
	cubeRootPrefix, _ := CubeRootPrefix(randomNum)
	t.Logf("cubeRootPrefix: 0x%x", cubeRootPrefix)
	cubed := new(big.Int).Exp(cubeRootPrefix, big.NewInt(3), nil).Bytes()
	t.Logf("cubed: 0x[%X]%x", cubed[:nPrefixBytesToMatch], cubed[nPrefixBytesToMatch:])

	if bytes.Compare(cubed[:nPrefixBytesToMatch], randomN[:nPrefixBytesToMatch]) != 0 {
		t.Fatalf("prefix mismatch")
	}
}

func TestCubeRootSuffix(t *testing.T) {
	randomN := make([]byte, 16)

	for {
		_, err := rand.Read(randomN)
		if err != nil {
			t.Fatalf("error generating random n: %s", err)
		}
		if randomN[len(randomN)-1]&1 == 0 {
			continue
		}
		break
	}

	keypair, err := impl_rsa_bleichenbacher_sig.GenerateRSAKeypairWithPublicExponent3()
	if err != nil {
		t.Fatalf("error generating rsa keypair: %s", err)
	}

	t.Logf("randomN: 0x[%X]", randomN)
	cubeRootSuffix := CubeRootSuffix(randomN)
	t.Logf("cubeRootSuffix: 0x%x", cubeRootSuffix)

	cubed := new(big.Int).Exp(new(big.Int).SetBytes(cubeRootSuffix), big.NewInt(3), keypair.PublicKey.N).Bytes()
	cubedSuffix := cubed[len(cubed)-len(randomN):]
	t.Logf("cubed: 0x%x[%X]", cubed[:len(cubed)-len(randomN)], cubedSuffix)

	if bytes.Compare(cubedSuffix, randomN) != 0 {
		t.Fatalf("suffix does not match")
	}
}

func TestGenerateSignatureForPublicExponent3(t *testing.T) {
	keypair, err := impl_rsa_bleichenbacher_sig.GenerateRSAKeypairWithPublicExponent3()
	if err != nil {
		t.Fatalf("error generating rsa keypair: %s", err)
	}

	digest := sha256.Sum256([]byte("Hello World!"))
	sig, err := ForgeSignatureForPublicExponent3(keypair.PublicKey, crypto.SHA256, digest[:])
	if err != nil {
		t.Fatalf("error forging signature: %s", err)
	}

	t.Logf("sig: %X", sig)

	err = impl_rsa_bleichenbacher_sig.VerifyPKCS1v15Insecure(keypair.PublicKey, crypto.SHA256, digest[:], sig)
	if err != nil {
		t.Fatalf("signature verification failed: %s", err)
	}

	t.Log("forged signatured verified successfully!")
}
