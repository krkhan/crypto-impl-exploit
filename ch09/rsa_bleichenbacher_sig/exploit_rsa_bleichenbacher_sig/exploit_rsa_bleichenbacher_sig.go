package exploit_rsa_bleichenbacher_sig

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"fmt"
	"math/big"

	"github.com/krkhan/crypto-impl-exploit/ch09/rsa_bleichenbacher_sig/impl_rsa_bleichenbacher_sig"
)

func CubeRootPrefix(prefix *big.Int) (cbrt *big.Int, rem *big.Int) {
	guess := new(big.Int).Div(prefix, big.NewInt(2))
	step := new(big.Int).Abs(new(big.Int).Div(guess, big.NewInt(2)))
	for {
		cube := new(big.Int).Exp(guess, big.NewInt(3), nil)
		dx := new(big.Int).Sub(prefix, cube)
		cmp := dx.Cmp(big.NewInt(0))
		if cmp == 0 {
			return guess, big.NewInt(0)
		}

		switch cmp {
		case -1:
			guess = new(big.Int).Sub(guess, step)
		case 1:
			guess = new(big.Int).Add(guess, step)
		}

		step = new(big.Int).Div(step, big.NewInt(2))
		if step.Cmp(big.NewInt(1)) == 0 {
			return guess, dx
		}
	}
}

func CubeRootSuffix(suffix []byte) []byte {
	suffixNum := new(big.Int).SetBytes(suffix)
	s := big.NewInt(1)

	for b := 0; b < len(suffix)*8; b++ {
		sCubed := new(big.Int).Exp(s, big.NewInt(3), nil)
		if sCubed.Bit(b) != suffixNum.Bit(b) {
			s.SetBit(s, b, 1)
		}
	}

	return s.Bytes()
}

func ForgeSignatureForPublicExponent3(pubKey *rsa.PublicKey, hashAlg crypto.Hash, digest []byte) ([]byte, error) {
	for {
		prefixRandom := make([]byte, (impl_rsa_bleichenbacher_sig.ModulusBits/8)-2)
		_, err := rand.Read(prefixRandom)
		if err != nil {
			return nil, err
		}

		prefix := []byte{0x00, 0x01}
		prefix = append(prefix, prefixRandom...)
		prefixCubeRoot, _ := CubeRootPrefix(new(big.Int).SetBytes(prefix))
		prefixCubeRootBytes := prefixCubeRoot.Bytes()

		var hashAsn1Identifier []byte
		switch hashAlg {
		case crypto.MD5:
			hashAsn1Identifier = []byte(impl_rsa_bleichenbacher_sig.HashAsn1Md5)
		case crypto.SHA1:
			hashAsn1Identifier = []byte(impl_rsa_bleichenbacher_sig.HashAsn1Sha1)
		case crypto.SHA256:
			hashAsn1Identifier = []byte(impl_rsa_bleichenbacher_sig.HashAsn1Sha256)
		}

		suffix := []byte{0x00}
		suffix = append(suffix, hashAsn1Identifier...)
		suffix = append(suffix, digest...)
		suffixCubeRoot := CubeRootSuffix(suffix)

		fmt.Printf("prefixCubeRoot: 0x%X\n", prefixCubeRoot)
		fmt.Printf("suffixCubeRoot: 0x%X\n", suffixCubeRoot)
		var sig []byte
		sig = append(sig, prefixCubeRootBytes[:len(prefixCubeRootBytes)-len(suffixCubeRoot)]...)
		fmt.Printf("sig: [0x%X]", sig)
		sig = append(sig, suffixCubeRoot...)
		fmt.Printf("[0x%X]\n", suffixCubeRoot)

		sigNum := new(big.Int).SetBytes(sig)
		sigCleartext := new(big.Int).Exp(sigNum, big.NewInt(3), nil).Bytes()
		if bytes.IndexByte(sigCleartext[:len(sigCleartext)-len(suffix)], byte(0x00)) != -1 {
			fmt.Printf("sigCleartext has a zero byte, retrying\n")
		} else {
			return sig, nil
		}
	}
}
