package exploit_ecdsa_reused_nonce

import (
	"fmt"
	"math/big"

	"github.com/krkhan/crypto-impl-exploit/ch09/ecdsa_reused_nonce/impl_ecdsa_reused_nonce"
)

func RecoverNonceFromBadSignatures(s1, s2, h1, h2 *big.Int) *big.Int {
	N := impl_ecdsa_reused_nonce.Curve.Params().N

	fmt.Printf("\ts1: 0x%X\n", s1)
	fmt.Printf("\ts2: 0x%X\n", s2)
	fmt.Printf("\th1: 0x%X\n", h1)
	fmt.Printf("\th2: 0x%X\n", h2)

	h1SubH2 := new(big.Int).Sub(h1, h2)
	h1SubH2ModN := new(big.Int).Mod(h1SubH2, N)
	s1SubS2 := new(big.Int).Sub(s1, s2)
	s1SubS2Inv := new(big.Int).ModInverse(s1SubS2, N)
	product := new(big.Int).Mul(h1SubH2ModN, s1SubS2Inv)
	nonce := new(big.Int).Mod(product, N)

	fmt.Printf("\tnonce: 0x%X\n", nonce)

	return nonce
}

func RecoverPrivateExponentUsingNonce(nonce, s, h, r *big.Int) *big.Int {
	N := impl_ecdsa_reused_nonce.Curve.Params().N

	fmt.Printf("\tnonce: 0x%X\n", nonce)
	fmt.Printf("\ts: 0x%X\n", s)
	fmt.Printf("\th: 0x%X\n", h)
	fmt.Printf("\tr: 0x%X\n", r)

	nonceIntoS := new(big.Int).Mul(nonce, s)
	nonceIntoSModN := new(big.Int).Mod(nonceIntoS, N)
	nonceIntoSMinusH := new(big.Int).Sub(nonceIntoSModN, h)
	rInv := new(big.Int).ModInverse(r, N)
	product := new(big.Int).Mul(nonceIntoSMinusH, rInv)
	privateExponent := new(big.Int).Mod(product, N)

	fmt.Printf("\tprivateExponent: 0x%X\n", privateExponent)

	return privateExponent
}
