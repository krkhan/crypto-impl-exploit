package exploit_ecdsa_reused_nonce

import (
	"crypto/ecdsa"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
	"testing"
	"time"

	"github.com/krkhan/crypto-impl-exploit/ch09/ecdsa_reused_nonce/impl_ecdsa_reused_nonce"
)

func TestRecoverNonceFromBadSignatures(t *testing.T) {
	keyPair, err := impl_ecdsa_reused_nonce.NewEcdsaKeyPair()
	if err != nil {
		t.Fatalf("error generating private key: %s", err)
	}

	h1 := sha256.Sum256([]byte("Hello World!"))
	h1Num := new(big.Int).SetBytes(h1[:])
	r1, s1, err := impl_ecdsa_reused_nonce.EcdsaSignUsingFixedNonce(keyPair, h1[:])
	if err != nil {
		t.Fatalf("error signing m1: %s", err)
	}
	t.Logf("r1: 0x%X", r1)

	h2 := sha256.Sum256([]byte(time.Now().String()))
	h2Num := new(big.Int).SetBytes(h2[:])
	r2, s2, err := impl_ecdsa_reused_nonce.EcdsaSignUsingFixedNonce(keyPair, h2[:])
	if err != nil {
		t.Fatalf("error signing m1: %s", err)
	}
	t.Logf("r2: 0x%X", r2)

	recoveredNonce := RecoverNonceFromBadSignatures(
		s1,
		s2,
		h1Num,
		h2Num,
	)

	t.Log("nonce recovered successfully")

	recoveredPrivateExponent := RecoverPrivateExponentUsingNonce(
		recoveredNonce,
		s1,
		h1Num,
		r1,
	)

	recoveredPrivateKey := &ecdsa.PrivateKey{
		PublicKey: *keyPair.PubKey,
		D:         recoveredPrivateExponent,
	}

	testMsg := []byte("Hello Universe!")
	testMsgHash := sha256.Sum256(testMsg)
	sig, err := ecdsa.SignASN1(rand.Reader, recoveredPrivateKey, testMsgHash[:])
	if err != nil {
		t.Fatalf("error using recovered private key for signing: %s", err)
	}

	ok := ecdsa.VerifyASN1(keyPair.PubKey, testMsgHash[:], sig)
	if !ok {
		t.Fatal("signature verification failed")
	}

	t.Log("private key recovered & verified successfully")
}
