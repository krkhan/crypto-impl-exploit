package impl_ecdsa_reused_nonce

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"fmt"
	"math/big"
)

type EcdsaKeyPair struct {
	PubKey  *ecdsa.PublicKey
	privKey *ecdsa.PrivateKey
}

var (
	Curve      elliptic.Curve
	notSoNonce *big.Int
)

func init() {
	Curve = elliptic.P256()
	n, err := rand.Int(rand.Reader, Curve.Params().N)
	if err != nil {
		panic("could not generate fixed value for nonce")
	}
	notSoNonce = n

	fmt.Printf("notSoNonce: 0x%X\n", notSoNonce)
}

func NewEcdsaKeyPair() (*EcdsaKeyPair, error) {
	priv, err := ecdsa.GenerateKey(Curve, rand.Reader)
	if err != nil {
		return nil, err
	}
	return &EcdsaKeyPair{
		PubKey:  &priv.PublicKey,
		privKey: priv,
	}, nil
}

func EcdsaSignUsingFixedNonce(key *EcdsaKeyPair, hash []byte) (*big.Int, *big.Int, error) {
	ke := notSoNonce
	keInv := new(big.Int).ModInverse(ke, Curve.Params().N)

	r, _ := Curve.ScalarBaseMult(ke.Bytes())
	h := new(big.Int).SetBytes(hash)
	Dr := new(big.Int).Mul(key.privKey.D, r)
	hashPlusDr := new(big.Int).Add(h, Dr)
	s := new(big.Int).Mul(hashPlusDr, keInv)
	sModN := new(big.Int).Mod(s, Curve.Params().N)

	return r, sModN, nil
}
