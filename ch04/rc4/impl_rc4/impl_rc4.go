package impl_rc4

type RC4 struct {
	key   []byte
	state [256]byte
}

func swap(x, y *byte) {
	tmp := *x
	*x = *y
	*y = tmp
}

func NewRC4(key []byte) *RC4 {
	rc4 := &RC4{
		key: make([]byte, len(key)),
	}
	copy(rc4.key, key)
	return rc4
}

func (rc4 *RC4) ksa() {
	for i := 0; i < 256; i++ {
		rc4.state[i] = byte(i)
	}
	j := 0
	for i := 0; i < 256; i++ {
		j = (j + int(rc4.state[i]) + int(rc4.key[i%len(rc4.key)])) % 256
		swap(&rc4.state[i], &rc4.state[j])
	}
}

func (rc4 *RC4) prga(length int) []byte {
	i := 0
	j := 0
	keyStream := make([]byte, length)
	for k := 0; k < length; k++ {
		i = (i + 1) % 256
		j = (j + int(rc4.state[i])) % 256
		swap(&rc4.state[i], &rc4.state[j])
		t := (int(rc4.state[i]) + int(rc4.state[j])) % 256
		keyStream[k] = rc4.state[t]
	}
	return keyStream
}

func (rc4 *RC4) Encrypt(plaintext []byte) []byte {
	rc4.ksa()
	keyStream := rc4.prga(len(plaintext))
	ciphertext := make([]byte, len(plaintext))
	for i := 0; i < len(plaintext); i++ {
		ciphertext[i] = plaintext[i] ^ keyStream[i]
	}
	return ciphertext
}
