package impl_rc4

import (
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().Unix())
}

type RC4 struct {
	key   []byte
	state [256]byte
}

func swap(x, y *byte) {
	tmp := *x
	*x = *y
	*y = tmp
}

func NewRC4(key []byte) *RC4 {
	rc4 := &RC4{
		key: make([]byte, len(key)),
	}
	copy(rc4.key, key)
	return rc4
}

func (rc4 *RC4) ksa() {
	for i := 0; i < 256; i++ {
		rc4.state[i] = byte(i)
	}
	j := 0
	for i := 0; i < 256; i++ {
		j = (j + int(rc4.state[i]) + int(rc4.key[i%len(rc4.key)])) % 256
		swap(&rc4.state[i], &rc4.state[j])
	}
}

func (rc4 *RC4) prga(length int) []byte {
	i := 0
	j := 0
	keyStream := make([]byte, length)
	for k := 0; k < length; k++ {
		i = (i + 1) % 256
		j = (j + int(rc4.state[i])) % 256
		swap(&rc4.state[i], &rc4.state[j])
		t := (int(rc4.state[i]) + int(rc4.state[j])) % 256
		keyStream[k] = rc4.state[t]
	}
	return keyStream
}

func (rc4 *RC4) Encrypt(plaintext []byte) []byte {
	rc4.ksa()
	keyStream := rc4.prga(len(plaintext))
	ciphertext := make([]byte, len(plaintext))
	for i := 0; i < len(plaintext); i++ {
		ciphertext[i] = plaintext[i] ^ keyStream[i]
	}
	return ciphertext
}

// https://www.ibm.com/docs/en/zvm/7.1?topic=structure-sub-network-access-protocol-snap
var SNAPHeader = [8]byte{0xAA, 0xAA, 0x03, 0x00, 0x00, 0x00, 0x08, 0x06}

type WEPPacketGenerator struct {
	psk []byte
}

func NewWEPPacketGenerator(psk []byte) *WEPPacketGenerator {
	generator := &WEPPacketGenerator{
		psk: make([]byte, len(psk)),
	}
	copy(generator.psk, psk)
	return generator
}

func (wpg *WEPPacketGenerator) GeneratePacketUsingWeakIV(targetIndex int) ([3]byte, []byte) {
	iv := [3]byte{byte(targetIndex), 255, byte(rand.Intn(256))}
	key := make([]byte, len(iv)+len(wpg.psk))
	copy(key[0:len(iv)], iv[:])
	copy(key[len(iv):], wpg.psk)
	rc4 := NewRC4(key)
	return iv, rc4.Encrypt(SNAPHeader[:])
}
