package exploit_rc4

import (
	"math/rand"
	"time"

	"github.com/krkhan/crypto-impl-exploit/ch04/rc4/impl_rc4"
)

func swap(x, y *byte) {
	tmp := *x
	*x = *y
	*y = tmp
}

func RecoverRC4PSK(psk []byte, targetIndex int, totalMessages int) byte {
	rand.Seed(time.Now().Unix())

	targetIndex += 3
	totalCount := 0
	freqDict := [256]int{}

	for i := 0; i < totalMessages; i++ {
		iv := [3]byte{byte(targetIndex), 255, byte(rand.Intn(256))}
		plaintextByte := byte(rand.Intn(256))
		key := make([]byte, len(iv)+len(psk))
		copy(key[0:len(iv)], iv[:])
		copy(key[len(iv):], psk)
		rc4 := impl_rc4.NewRC4(key)
		ciphertextByte := rc4.Encrypt([]byte{plaintextByte})[0]
		keystreamByte := plaintextByte ^ ciphertextByte

		state := [256]byte{}
		for i := 0; i < 256; i++ {
			state[i] = byte(i)
		}
		j := 0
		for i := 0; i < targetIndex; i++ {
			j = (j + int(state[i]) + int(key[i])) % 256
			swap(&state[i], &state[j])
		}
		candidateKey := (int(keystreamByte) - j - int(state[targetIndex])) % 256
		if candidateKey < 0 {
			candidateKey += 256
		}
		freqDict[candidateKey] += 1
		totalCount += 1
	}

	for i := 0; i < 256; i++ {
		freqPercentage := float64(freqDict[i]) / float64(totalCount) * 100
		if freqPercentage > 3 {
			return byte(i)
		}
	}

	return 0x00
}
