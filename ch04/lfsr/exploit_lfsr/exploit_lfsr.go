package exploit_lfsr

import (
	"errors"

	"github.com/OpenWhiteBox/primitives/matrix"
	"github.com/krkhan/crypto-impl-exploit/ch04/lfsr/impl_lfsr"
)

func CloneLFSRWithLength(originalLfsr *impl_lfsr.LFSR, lfsrLength int) (*impl_lfsr.LFSR, error) {
	observedBits := make([]byte, lfsrLength*2)

	for i := 0; i < lfsrLength*2; i++ {
		observedBits[i] = originalLfsr.GenerateBit()
	}

	outputMatrix := matrix.GenerateEmpty(lfsrLength, lfsrLength)
	for i := 0; i < lfsrLength; i++ {
		for j := 0; j < lfsrLength; j++ {
			outputMatrix[i].SetBit(j, observedBits[i+j] != 0x00)
		}
	}

	invertMatrix, ok := outputMatrix.Invert()
	if !ok {
		return nil, errors.New("invert matrix does not exist")
	}

	xMatrix := matrix.GenerateEmpty(lfsrLength, 1)
	for i := 0; i < lfsrLength; i++ {
		xMatrix[i].SetBit(0, observedBits[lfsrLength+i] != 0x00)
	}
	tapsMatrix := invertMatrix.Compose(xMatrix)

	recoveredTaps := make([]byte, lfsrLength)
	for i := 0; i < lfsrLength; i++ {
		recoveredTaps[lfsrLength-i-1] = tapsMatrix[i].GetBit(0)
	}

	recoveredState := make([]byte, lfsrLength)
	for i := 0; i < lfsrLength; i++ {
		recoveredState[i] = observedBits[len(observedBits)-1-i]
	}

	return impl_lfsr.NewLFSR(lfsrLength, recoveredTaps, recoveredState), nil
}

func CloneLFSR(originalLfsr *impl_lfsr.LFSR) (*impl_lfsr.LFSR, error) {
	for i := 1; i < 256; i++ {
		if clonedLfsr, err := CloneLFSRWithLength(originalLfsr, i); err == nil {
			return clonedLfsr, nil
		}
	}
	return nil, errors.New("could not recover LFSR")
}
