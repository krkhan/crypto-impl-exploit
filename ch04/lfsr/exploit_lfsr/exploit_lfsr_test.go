package exploit_lfsr

import (
	"math/rand"
	"testing"
	"time"

	"github.com/krkhan/crypto-impl-exploit/ch04/lfsr/impl_lfsr"
)

func TestCloneLFSRWithKnownLengths(t *testing.T) {
	length := 8
	taps := []byte{0, 1, 1, 1, 0, 0, 0, 1}
	state := []byte{1, 1, 0, 1, 0, 1, 0, 1}
	originalRng := impl_lfsr.NewLFSR(length, taps, state)
	clonedRng, err := CloneLFSRWithKnownLength(originalRng, length)
	if err != nil {
		t.Fatalf("cloning failed")
	}
	for i := 0; i < 100; i++ {
		cloned := clonedRng.GenerateBit()
		observed := originalRng.GenerateBit()
		if observed != cloned {
			t.Fatalf("observed: %d, cloned: %d", cloned, observed)
		}
	}

	length = 16
	taps = []byte{0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
	state = []byte{1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0}
	originalRng = impl_lfsr.NewLFSR(length, taps, state)
	clonedRng, err = CloneLFSRWithKnownLength(originalRng, length)
	if err != nil {
		t.Fatalf("cloning failed")
	}
	for i := 0; i < 100; i++ {
		cloned := clonedRng.GenerateBit()
		observed := originalRng.GenerateBit()
		if observed != cloned {
			t.Fatalf("observed: %d, cloned: %d", cloned, observed)
		}
	}

	length = 32
	taps = make([]byte, 32)
	taps[1] = 0x01
	taps[5] = 0x01
	taps[6] = 0x01
	taps[31] = 0x01
	state = make([]byte, 32)
	state[3] = 0x01
	state[16] = 0x01
	state[18] = 0x01
	state[25] = 0x01
	originalRng = impl_lfsr.NewLFSR(length, taps, state)
	clonedRng, err = CloneLFSRWithKnownLength(originalRng, length)
	if err != nil {
		t.Fatalf("cloning failed")
	}
	for i := 0; i < 100; i++ {
		cloned := clonedRng.GenerateBit()
		observed := originalRng.GenerateBit()
		if observed != cloned {
			t.Fatalf("observed: %d, cloned: %d", cloned, observed)
		}
	}
}

func TestCloneLFSRWithUnknownLength(t *testing.T) {
	length := 16
	taps := []byte{0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
	state := []byte{1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0}
	originalRng := impl_lfsr.NewLFSR(length, taps, state)
	clonedRng, err := CloneLFSR(originalRng)
	if err != nil {
		t.Fatalf("cloning failed")
	}
	for i := 0; i < 100; i++ {
		cloned := clonedRng.GenerateBit()
		observed := originalRng.GenerateBit()
		if observed != cloned {
			t.Fatalf("observed: %d, cloned: %d", cloned, observed)
		}
	}
}

const AttackMessageKnownPrefix = "ATTACK AT "

func GenerateEncryptedAttackMessage() []byte {
	rand.Seed(time.Now().Unix())
	minTime := time.Date(2022, 1, 0, 0, 0, 0, 0, time.UTC).Unix()
	maxTime := time.Date(2025, 1, 0, 0, 0, 0, 0, time.UTC).Unix()
	deltaTime := maxTime - minTime
	seconds := rand.Int63n(deltaTime) + minTime
	plaintext := AttackMessageKnownPrefix + time.Unix(seconds, 0).String()

	seed := uint16(rand.Intn(256) % 256)
	lfsr := impl_lfsr.NewLFSR16Bit(seed)
	return lfsr.Encrypt([]byte(plaintext))
}

func TestKnownPlaintextAttack(t *testing.T) {
	ciphertext := GenerateEncryptedAttackMessage()
	t.Logf("Ciphertext: %s\n", ciphertext)
	keystreamBits := make([]byte, 8*len(AttackMessageKnownPrefix))
	for i := 0; i < len(AttackMessageKnownPrefix); i++ {
		keystreamByte := ciphertext[i] ^ AttackMessageKnownPrefix[i]
		for j := 0; j < 8; j++ {
			keystreamBits[8*i+j] = (keystreamByte >> (7 - j)) & 1
		}
	}
	recoveredLfsr, err := RecoverLFSRFromObservedBits(keystreamBits)
	if err != nil {
		t.Error(err)
	}
	remainingCiphertext := ciphertext[len(AttackMessageKnownPrefix):]
	decrypted := recoveredLfsr.Encrypt(remainingCiphertext)
	t.Logf("Decrypted message: %s%s\n", AttackMessageKnownPrefix, decrypted)
}
