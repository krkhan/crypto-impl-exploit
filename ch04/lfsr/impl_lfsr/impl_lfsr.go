package impl_lfsr

type LFSR struct {
	length int
	taps   []byte
	state  []byte
}

func NewLFSR(length int, taps []byte, state []byte) *LFSR {
	lfsr := &LFSR{
		length,
		make([]byte, len(taps)),
		make([]byte, len(state)),
	}

	copy(lfsr.state, state)
	copy(lfsr.taps, taps)

	for i := 0; i < length; i++ {
		lfsr.GenerateBit()
	}

	return lfsr
}

func NewLFSR16Bit(seed uint16) *LFSR {
	length := 16
	state := []byte{}
	for i := 15; i >= 0; i-- {
		state = append(state, byte(seed>>i&1))
	}
	taps := []byte{0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
	return NewLFSR(length, taps, state)
}

func (lfsr *LFSR) GenerateBit() byte {
	outputBit := lfsr.state[lfsr.length-1]

	newShiftBit := byte(0x00)
	for i := 0; i < lfsr.length; i++ {
		newShiftBit = newShiftBit ^ (lfsr.taps[i] & lfsr.state[i])
	}

	for i := lfsr.length - 1; i > 0; i-- {
		lfsr.state[i] = lfsr.state[i-1]
	}

	lfsr.state[0] = newShiftBit

	return outputBit
}

func (lfsr *LFSR) Encrypt(plaintext []byte) []byte {
	result := make([]byte, len(plaintext))

	for i := 0; i < len(plaintext); i++ {
		keyStream := byte(0x00)
		for j := 7; j >= 0; j-- {
			keyStream = keyStream ^ (lfsr.GenerateBit() << j)
		}
		result[i] = keyStream ^ plaintext[i]
	}

	return result
}
