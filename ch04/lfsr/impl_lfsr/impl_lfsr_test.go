package impl_lfsr

import (
	"testing"
)

func TestLFSR8Bit(t *testing.T) {
	length := 8
	state := []byte{1, 1, 0, 1, 0, 1, 0, 1}
	taps := []byte{0, 1, 1, 1, 0, 0, 0, 1}
	lfsr := NewLFSR(length, taps, state)
	expected := []byte{1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1}
	for i := 0; i < len(expected); i++ {
		if r := lfsr.GenerateBit(); r != expected[i] {
			t.Fatalf("Generated: %d, Expected: %d.", r, expected[i])
		}
	}
}

func TestLFSR16Bit(t *testing.T) {
	lfsr := NewLFSR16Bit(0xD5D6)
	expected := []byte{1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1}
	for i := 0; i < len(expected); i++ {
		if r := lfsr.GenerateBit(); r != expected[i] {
			t.Fatalf("Generated: %d, Expected: %d.", r, expected[i])
		}
	}

	lfsr = NewLFSR16Bit(0x4F2D)
	expected = []byte{1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0}
	for i := 0; i < len(expected); i++ {
		if r := lfsr.GenerateBit(); r != expected[i] {
			t.Fatalf("Generated: %d, Expected: %d.", r, expected[i])
		}
	}
}

func TestLFSREncrypt(t *testing.T) {
	length := 8
	state := []byte{1, 1, 0, 1, 0, 1, 0, 1}
	taps := []byte{0, 1, 1, 1, 0, 0, 0, 1}
	lfsr := NewLFSR(length, taps, state)

	plaintext := []byte{0x11, 0x22, 0x33, 0x44, 0x55}
	expected := []byte{0x92, 0x37, 0xAA, 0x3A, 0xA6}
	encrypted := lfsr.Encrypt(plaintext)

	for i := 0; i < len(expected); i++ {
		if encrypted[i] != expected[i] {
			t.Fatalf("Encrypted: 0x%02X, Expected: 0x%02X", encrypted[i], expected[i])
		}
	}
}
