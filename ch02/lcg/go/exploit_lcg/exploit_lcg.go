package exploit_lcg

import (
	"github.com/krkhan/crypto-impl-exploit/ch02/lcg/go/impl_lcg"
	"math/big"
)

func findModInverse(a, m int64) int64 {
	return new(big.Int).ModInverse(big.NewInt(a), big.NewInt(m)).Int64()
}

func findGCD(a, b int64) int64 {
	return new(big.Int).GCD(nil, nil, big.NewInt(a), big.NewInt(b)).Int64()
}

func findModulus(originalRng *impl_lcg.LCG) int {
	var diffs []int
	previousValue := originalRng.Generate()
	for i := 0; i < 1000; i++ {
		currentValue := originalRng.Generate()
		diffs = append(diffs, currentValue-previousValue)
		previousValue = currentValue
	}

	var zeros []int
	for i := 2; i < len(diffs); i++ {
		zeros = append(zeros, diffs[i]*diffs[i-2]-diffs[i-1]*diffs[i-1])
	}

	gcd := 0
	for _, v := range zeros {
		gcd = int(findGCD(int64(gcd), int64(v)))
	}

	return gcd
}

func findMultiplier(originalRng *impl_lcg.LCG, modulus int) int {
	s0, s1, s2 := originalRng.Generate(), originalRng.Generate(), originalRng.Generate()
	inverse := int(findModInverse(int64(s1-s0), int64(modulus)))
	multiplier := (s2 - s1) * inverse % modulus
	if multiplier < 0 {
		return modulus + multiplier
	} else {
		return multiplier
	}
}

func findIncrement(originalRng *impl_lcg.LCG, modulus, multiplier int) int {
	s0, s1 := originalRng.Generate(), originalRng.Generate()
	return (s1 - s0*multiplier) % modulus
}

func CloneLCG(originalRng *impl_lcg.LCG) *impl_lcg.LCG {
	modulus := findModulus(originalRng)
	multiplier := findMultiplier(originalRng, modulus)
	increment := findIncrement(originalRng, modulus, multiplier)
	seed := originalRng.Generate()
	clonedRng := impl_lcg.NewLCG(multiplier, increment, modulus, seed)
	return clonedRng
}
