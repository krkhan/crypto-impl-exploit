package exploit_lcg

import (
	"github.com/krkhan/crypto-impl-exploit/ch02/lcg/go/impl_lcg"
)

func calculateGCD(a, b int) int {
	for b != 0 {
		t := b
		b = a % b
		a = t
	}
	return a
}

func findModulus(originalRng *impl_lcg.LCG) int {
	var diffs []int
	previousValue := originalRng.Generate()
	for i := 0; i < 1000; i++ {
		currentValue := originalRng.Generate()
		diffs = append(diffs, currentValue-previousValue)
		previousValue = currentValue
	}

	var zeros []int
	for i := 2; i < len(diffs); i++ {
		zeros = append(zeros, diffs[i]*diffs[i-2]-diffs[i-1]*diffs[i-1])
	}

	gcd := 0
	for _, v := range zeros {
		gcd = calculateGCD(gcd, v)
	}

	if gcd < 0 {
		return gcd * -1
	} else {
		return gcd
	}
}

func egcdHelper(a, b int) (int, int, int) {
	if a == 0 {
		return b, 0, 1
	} else {
		g, y, x := egcdHelper(b%a, a)
		return g, x - (b/a)*y, y
	}
}

func findModInverse(a, m int) int {
	if a < 0 {
		a = m + a
	}
	g, x, _ := egcdHelper(a, m)
	if g != 1 {
		panic("mod inverse does not exist")
	} else {
		return x % m
	}
}

func findMultiplier(originalRng *impl_lcg.LCG, modulus int) int {
	s0, s1, s2 := originalRng.Generate(), originalRng.Generate(), originalRng.Generate()
	inverse := findModInverse(s1-s0, modulus)
	multiplier := (s2 - s1) * inverse % modulus
	if multiplier < 0 {
		return modulus + multiplier
	} else {
		return multiplier
	}
}

func findIncrement(originalRng *impl_lcg.LCG, modulus, multiplier int) int {
	s0, s1 := originalRng.Generate(), originalRng.Generate()
	return (s1 - s0*multiplier) % modulus
}

func CloneLCG(originalRng *impl_lcg.LCG) *impl_lcg.LCG {
	modulus := findModulus(originalRng)
	multiplier := findMultiplier(originalRng, modulus)
	increment := findIncrement(originalRng, modulus, multiplier)
	seed := originalRng.Generate()
	clonedRng := impl_lcg.NewLCG(multiplier, increment, modulus, seed)
	return clonedRng
}
