package impl_common_factors

import (
	cryptoRand "crypto/rand"
	"crypto/rsa"
	"math/big"
	mathRand "math/rand"
	"time"
)

const (
	ModulusBits     = 1024
	PrimesPoolTotal = 512
)

var (
	PrimesPool [PrimesPoolTotal]*big.Int
)

func init() {
	for i := 0; i < PrimesPoolTotal; i++ {
		p, err := cryptoRand.Prime(cryptoRand.Reader, ModulusBits/2)
		if err != nil {
			panic("error generating prime")
		}
		PrimesPool[i] = p
	}
}

func GenerateRSAPrivateKeyUsingChilledRng() (*rsa.PrivateKey, error) {
	rng := mathRand.New(mathRand.NewSource(time.Now().UnixMicro()))
	var p, q *big.Int
	for {
		p = PrimesPool[rng.Intn(PrimesPoolTotal)]
		q = PrimesPool[rng.Intn(PrimesPoolTotal)]
		if p != q {
			break
		}
	}

	pMinus1 := new(big.Int).Sub(p, big.NewInt(1))
	qMinus1 := new(big.Int).Sub(q, big.NewInt(1))
	modulus := new(big.Int).Mul(p, q)
	phi := new(big.Int).Mul(pMinus1, qMinus1)

	var err error
	e := new(big.Int)
	for {
		e, err = cryptoRand.Int(cryptoRand.Reader, big.NewInt(1<<31-1))
		if err != nil {
			return nil, err
		}
		egcd := new(big.Int).GCD(nil, nil, e, phi)
		if egcd.Int64() == 1 {
			break
		}
	}

	d := new(big.Int).ModInverse(e, phi)

	pubKey := &rsa.PublicKey{
		N: modulus,
		E: int(e.Int64()),
	}
	privKey := &rsa.PrivateKey{
		PublicKey: *pubKey,
		D:         d,
		Primes:    []*big.Int{p, q},
	}

	err = privKey.Validate()
	if err != nil {
		return nil, err
	}

	return privKey, nil
}

func GenerateRSAPublicKeyAndCiphertext() (*rsa.PublicKey, []byte, error) {
	privKey, err := GenerateRSAPrivateKeyUsingChilledRng()
	if err != nil {
		return nil, nil, err
	}

	pubKey := &rsa.PublicKey{
		N: privKey.N,
		E: privKey.E,
	}

	message := time.Now().String()

	ciphertext, err := rsa.EncryptPKCS1v15(cryptoRand.Reader, pubKey, []byte(message))
	if err != nil {
		return nil, nil, err
	}

	return &privKey.PublicKey, ciphertext, nil
}
