package impl_short_priv_exp

import (
	cryptoRand "crypto/rand"
	"math/big"
	"time"
)

const (
	ModulusBits = 1024
)

type PublicKey struct {
	N *big.Int
	E *big.Int
}

type PrivateKey struct {
	PublicKey
	D *big.Int
}

func GenerateVulnerableRSAPrivateKey() (*PrivateKey, error) {
	var p, q *big.Int
	var err error

	for {
		p, err = cryptoRand.Prime(cryptoRand.Reader, ModulusBits/2)
		if err != nil {
			return nil, err
		}

		q, err = cryptoRand.Prime(cryptoRand.Reader, ModulusBits/2)
		if err != nil {
			return nil, err
		}

		if p.Cmp(q) == 1 {
			p, q = q, p
		}

		qDouble := new(big.Int).Mul(q, big.NewInt(2))

		if p.Cmp(qDouble) == -1 {
			break
		}
	}

	modulus := new(big.Int).Mul(p, q)
	pMinus1 := new(big.Int).Sub(p, big.NewInt(1))
	qMinus1 := new(big.Int).Sub(q, big.NewInt(1))
	phi := new(big.Int).Mul(pMinus1, qMinus1)

	nSqrtSqrt := new(big.Int).Sqrt(new(big.Int).Sqrt(modulus))
	maxD := new(big.Int).Div(nSqrtSqrt, big.NewInt(3))

	var d *big.Int
	for {
		d, err = cryptoRand.Prime(cryptoRand.Reader, maxD.BitLen())
		if err != nil {
			return nil, err
		}

		if new(big.Int).GCD(nil, nil, d, phi).Int64() == 1 {
			break
		}
	}

	e := new(big.Int).ModInverse(d, phi)

	privKey := &PrivateKey{
		PublicKey: PublicKey{
			N: modulus,
			E: e,
		},
		D: d,
	}

	return privKey, nil
}

func (pubKey *PublicKey) Encrypt(plaintext *big.Int) (ciphertext *big.Int) {
	ciphertext = new(big.Int).Exp(plaintext, pubKey.E, pubKey.N)
	return
}

func (privKey *PrivateKey) Decrypt(ciphertext *big.Int) (plaintext *big.Int) {
	plaintext = new(big.Int).Exp(ciphertext, privKey.D, privKey.N)
	return
}

func GenerateRSAPublicKeyAndCiphertext() (*PublicKey, *big.Int, error) {
	privKey, err := GenerateVulnerableRSAPrivateKey()
	if err != nil {
		return nil, nil, err
	}

	pubKey := &PublicKey{
		N: privKey.N,
		E: privKey.E,
	}

	messageString := time.Now().String()
	message := new(big.Int).SetBytes([]byte(messageString))
	ciphertext := pubKey.Encrypt(message)

	return pubKey, ciphertext, nil
}
