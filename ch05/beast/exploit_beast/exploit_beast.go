package exploit_beast

import (
	"bytes"
	"crypto/aes"
	"fmt"
	"strings"

	"github.com/krkhan/crypto-impl-exploit/ch05/beast/impl_beast"
)

func RecoverSessionIDFromEncryptedHTTPSession(host string) (string, error) {
	var sessionIdRecovered []byte

	for i := 0; i < impl_beast.SessionIdLength; i++ {
		recoveredByte, err := recoverNextByteOfSessionId(host, sessionIdRecovered)
		if err != nil {
			return "", err
		}
		sessionIdRecovered = append(sessionIdRecovered, recoveredByte)
	}

	return string(sessionIdRecovered), nil
}

func recoverNextByteOfSessionId(host string, sessionIdRecovered []byte) (byte, error) {
	pathPrefix := "/dummypath"
	sessionIdPlaceholder := make([]byte, impl_beast.SessionIdLength)
	for i := 0; i < len(sessionIdPlaceholder); i++ {
		sessionIdPlaceholder[i] = '0'
	}
	firstRequestPlaintext := fmt.Sprintf(impl_beast.HTTPRequestTemplate, pathPrefix, host, sessionIdPlaceholder)

	sessionIdKey := "SESSIONID="
	sessionIdIndex := strings.Index(firstRequestPlaintext, sessionIdKey) + len(sessionIdKey) + len(sessionIdRecovered)

	targetBlock := sessionIdIndex / aes.BlockSize
	targetBlockOffset := sessionIdIndex % aes.BlockSize

	var pathSlider []byte
	for i := targetBlockOffset; i < aes.BlockSize-1; i++ {
		pathSlider = append(pathSlider, byte('X'))
	}

	for i := 0; i < 256; i++ {
		pathWithPadding := fmt.Sprintf("%s%s", pathPrefix, pathSlider)
		for k := 0; k < len(sessionIdRecovered); k++ {
			sessionIdPlaceholder[k] = sessionIdRecovered[k]
		}
		sessionIdPlaceholder[len(sessionIdRecovered)] = byte(i)
		firstRequestPlaintext = fmt.Sprintf(impl_beast.HTTPRequestTemplate, pathWithPadding, host, sessionIdPlaceholder)

		session, firstRequestCiphertext, err := impl_beast.NewEncryptedHTTPSession(host, pathWithPadding)
		if err != nil {
			return 0x00, fmt.Errorf("error creating new http session: %s", err)
		}

		c1 := firstRequestCiphertext[(targetBlock-1)*aes.BlockSize : (targetBlock)*aes.BlockSize]
		p2 := []byte(firstRequestPlaintext[(targetBlock)*aes.BlockSize : (targetBlock+1)*aes.BlockSize])
		c2 := firstRequestCiphertext[(targetBlock)*aes.BlockSize : (targetBlock+1)*aes.BlockSize]
		c4 := firstRequestCiphertext[len(firstRequestCiphertext)-aes.BlockSize:]

		p5 := make([]byte, aes.BlockSize)
		for j := 0; j < aes.BlockSize; j++ {
			p5[j] = c1[j] ^ p2[j] ^ c4[j]
		}
		c5, err := session.EncryptRequest(p5)
		if err != nil {
			return 0x00, fmt.Errorf("error encrypting request: %s", err)
		}
		if bytes.Equal(c5, c2) {
			return byte(i), nil
		}
	}

	return 0x00, fmt.Errorf("no guess worked")
}
