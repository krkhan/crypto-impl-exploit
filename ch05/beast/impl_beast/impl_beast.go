package impl_beast

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/hex"
	"fmt"

	"github.com/krkhan/crypto-impl-exploit/ch05/padding_oracle/impl_padding_oracle"
)

const SessionIdLength = 8
const HTTPRequestTemplate = ("GET %s HTTP/1.1\n" +
	"Host: %s\n" +
	"Cookie: SESSIONID=%s\n" +
	"User-Agent: BEAST-Vulnerable Browser\n\n")

var cookieJar map[string]string

type EncryptedHTTPSession struct {
	Host      string
	Path      string
	encrypter cipher.BlockMode
}

func init() {
	cookieJar = make(map[string]string)
}

func generateSessionId() (string, error) {
	bytes := make([]byte, SessionIdLength/2)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}

	hexString := hex.EncodeToString(bytes)
	return hexString, nil
}

func ValidateSessionId(host string, sessionId string) bool {
	storedSessionId, ok := cookieJar[host]
	return ok && storedSessionId == sessionId
}

func NewEncryptedHTTPSession(host, path string) (*EncryptedHTTPSession, []byte, error) {
	if _, ok := cookieJar[host]; !ok {
		sessionId, err := generateSessionId()
		if err != nil {
			return nil, nil, err
		}
		cookieJar[host] = sessionId
	}
	cookie, _ := cookieJar[host]

	key := make([]byte, aes.BlockSize)
	if _, err := rand.Read(key); err != nil {
		return nil, nil, fmt.Errorf("could not generate random key")
	}

	blockCipher, err := aes.NewCipher(key)
	if err != nil {
		return nil, nil, err
	}

	iv := make([]byte, aes.BlockSize)
	if _, err := rand.Read(iv); err != nil {
		return nil, nil, fmt.Errorf("could not generate random key")
	}

	encrypter := cipher.NewCBCEncrypter(blockCipher, iv)
	session := &EncryptedHTTPSession{
		Host:      host,
		Path:      path,
		encrypter: encrypter,
	}

	firstRequest := fmt.Sprintf(HTTPRequestTemplate, path, host, cookie)
	firstRequestPadded, err := impl_padding_oracle.PadWithPKCS7([]byte(firstRequest), aes.BlockSize)
	if err != nil {
		return nil, nil, fmt.Errorf("could not pad first request")
	}

	firstRequestCiphertext := make([]byte, len(firstRequestPadded))
	encrypter.CryptBlocks(firstRequestCiphertext, firstRequestPadded)
	return session, firstRequestCiphertext, nil
}

func (session *EncryptedHTTPSession) EncryptRequest(plaintext []byte) ([]byte, error) {
	if len(plaintext)%aes.BlockSize != 0 {
		return nil, fmt.Errorf("invalid plaintext block size")
	}
	ciphertext := make([]byte, len(plaintext))
	session.encrypter.CryptBlocks(ciphertext, plaintext)
	return ciphertext, nil
}
