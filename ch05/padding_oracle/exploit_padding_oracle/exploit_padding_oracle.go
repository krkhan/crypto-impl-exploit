package exploit_padding_oracle

import (
	"crypto/aes"

	"github.com/krkhan/crypto-impl-exploit/ch05/padding_oracle/impl_padding_oracle"
)

func RecoverPlaintextFromPaddingOracle(server *impl_padding_oracle.PaddingOracleServer, ciphertext []byte) ([]byte, error) {
	var recoveredPlaintextFull []byte
	totalBlocks := len(ciphertext) / aes.BlockSize

	for n := totalBlocks; n > 1; n-- {
		targetBlockCiphertextOriginal := ciphertext[(n-1)*aes.BlockSize : (n)*aes.BlockSize]
		precedingBlockCiphertextOriginal := ciphertext[(n-2)*aes.BlockSize : (n-1)*aes.BlockSize]
		precedingBlockCiphertextCopy := append([]byte(nil), precedingBlockCiphertextOriginal...)
		targetBlockPlaintextRecovered := make([]byte, aes.BlockSize)

		for padding := 1; padding <= aes.BlockSize; padding++ {
			for bruteforceAttempt := 0; bruteforceAttempt < 256; bruteforceAttempt++ {
				precedingBlockCiphertextCopy[aes.BlockSize-padding]++

				joinedCiphertextBlocks := append(
					append([]byte(nil), precedingBlockCiphertextCopy...),
					targetBlockCiphertextOriginal...)

				_, err := server.CalculateTimeDifference(joinedCiphertextBlocks)

				// if we do *not* get a padding error then our guess is correct

				if _, ok := err.(*impl_padding_oracle.InvalidPaddingError); !ok {
					intermediateValue := precedingBlockCiphertextCopy[aes.BlockSize-padding] ^ byte(padding)
					targetBlockPlaintextRecovered[aes.BlockSize-padding] = precedingBlockCiphertextOriginal[aes.BlockSize-padding] ^ intermediateValue
					for k := 1; k < padding+1; k++ {
						precedingBlockCiphertextCopy[aes.BlockSize-k] = byte(padding+1) ^ targetBlockPlaintextRecovered[aes.BlockSize-k] ^ precedingBlockCiphertextOriginal[aes.BlockSize-k]
					}
					break
				}
			}
		}

		recoveredPlaintextFull = append(targetBlockPlaintextRecovered, recoveredPlaintextFull...)
	}

	return recoveredPlaintextFull, nil
}
