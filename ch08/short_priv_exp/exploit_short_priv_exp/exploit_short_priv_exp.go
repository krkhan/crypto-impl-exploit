package exploit_short_priv_exp

import (
	"fmt"
	"math/big"
	"time"

	"github.com/krkhan/crypto-impl-exploit/ch08/short_priv_exp/impl_short_priv_exp"
)

type Fraction struct {
	Numerator   *big.Int
	Denominator *big.Int
}

func ContinuedFraction(f Fraction) (quotients []*big.Int) {
	for f.Denominator.Cmp(big.NewInt(0)) != 0 {
		quotients = append(quotients, new(big.Int).Div(f.Numerator,
			f.Denominator))
		f = Fraction{f.Denominator, new(big.Int).Rem(f.Numerator,
			f.Denominator)}
	}

	return
}

func Convergents(quotients []*big.Int) (convergents []Fraction) {
	niMinus2, diMinus2 := big.NewInt(0), big.NewInt(1)
	niMinus1, diMinus1 := big.NewInt(1), big.NewInt(0)

	for _, quotient := range quotients {
		quotientNiMinus1 := new(big.Int).Mul(quotient, niMinus1)
		quotientDiMinus1 := new(big.Int).Mul(quotient, diMinus1)

		ni := new(big.Int).Add(quotientNiMinus1, niMinus2)
		di := new(big.Int).Add(quotientDiMinus1, diMinus2)

		convergents = append(convergents, Fraction{ni, di})

		niMinus2, niMinus1 = niMinus1, ni
		diMinus2, diMinus1 = diMinus1, di
	}

	return
}

func RecoverPrivateKeyUsingWienersAttack(pubKey *impl_short_priv_exp.PublicKey) (privKey *impl_short_priv_exp.PrivateKey, err error) {
	convergents := Convergents(ContinuedFraction(Fraction{
		Numerator:   pubKey.E,
		Denominator: pubKey.N,
	}))

	for _, frac := range convergents {
		candidateD := frac.Denominator
		privKey = &impl_short_priv_exp.PrivateKey{
			PublicKey: *pubKey,
			D:         candidateD,
		}

		plaintext := new(big.Int).SetBytes([]byte(time.Now().String()))
		ciphertext := pubKey.Encrypt(plaintext)
		decrypted := privKey.Decrypt(ciphertext)

		if decrypted.Cmp(plaintext) == 0 {
			return
		}
	}

	return nil, fmt.Errorf("attack failed")
}
