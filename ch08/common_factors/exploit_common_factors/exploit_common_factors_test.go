package exploit_common_factors

import (
	cryptoRand "crypto/rand"
	"crypto/rsa"
	"testing"

	"github.com/krkhan/crypto-impl-exploit/ch08/common_factors/impl_common_factors"
)

const (
	TotalKeypairs = 48
)

func TestCommonFactorsAttack(t *testing.T) {
	t.Logf("generating %d keypairs using a pool of %d primes", TotalKeypairs, impl_common_factors.PrimesPoolTotal)

	type testCase struct {
		pubKey     *rsa.PublicKey
		ciphertext []byte
	}
	var testCases []testCase
	var pubKeys []*rsa.PublicKey

	for i := 0; i < TotalKeypairs; i++ {
		pubKey, ciphertext, err := impl_common_factors.GenerateRSAPublicKeyAndCiphertext()
		if err != nil {
			t.Fatalf("error generating keypairs: %s", err)
		}
		testCases = append(testCases, testCase{
			pubKey,
			ciphertext,
		})
		pubKeys = append(pubKeys, pubKey)
	}

	recoveredPrivKeys, err := RecoverPrivateKeysUsingCommonFactors(pubKeys)
	if err != nil {
		t.Fatalf("error finding common factors: %s", err)
	}

	if len(recoveredPrivKeys) == 0 {
		t.Fatalf("could not recover any private keys")
	}

	t.Logf("recovered %d private keys from %d public keys", len(recoveredPrivKeys), len(pubKeys))

	for _, testCase := range testCases {
		for _, privKey := range recoveredPrivKeys {
			if testCase.pubKey.E != privKey.E || testCase.pubKey.N.Cmp(privKey.N) != 0 {
				continue
			}

			decrypted, err := rsa.DecryptPKCS1v15(cryptoRand.Reader, privKey, testCase.ciphertext)
			if err != nil {
				t.Fatalf("error decrypting: %s", err)
			}

			t.Logf("decrypted: %s", decrypted)
		}
	}
}
