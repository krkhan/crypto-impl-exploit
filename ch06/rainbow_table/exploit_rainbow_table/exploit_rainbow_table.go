package exploit_rainbow_table

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"errors"
	"fmt"

	"github.com/krkhan/crypto-impl-exploit/ch06/rainbow_table/impl_rainbow_table"
)

const ChainLength = 1000

type RainbowTable map[string]string

func ReduceSHA256Hash(digest [sha256.Size]byte, column int) []byte {
	var result []byte
	for i := 0; i < impl_rainbow_table.PasswordLength; i++ {
		selector := (int(digest[i]) ^ column) % len(impl_rainbow_table.PasswordCharset)
		if selector < 0 {
			selector += len(impl_rainbow_table.PasswordCharset)
		}
		value := impl_rainbow_table.PasswordCharset[selector]
		result = append(result, value)
	}
	return result
}

func (table *RainbowTable) PopulateRainbowTable(rows int) {
	for i := 0; i < rows; i++ {
		if i%1000 == 0 {
			fmt.Printf("generated %d/%d rows (%.2f%%)\r", i, rows, float64(i)/float64(rows)*100.0)
		}

		start := impl_rainbow_table.GenerateRandomPassword(impl_rainbow_table.PasswordLength)
		message := start
		var hashDigest [sha256.Size]byte
		for column := 0; column < ChainLength; column++ {
			hashDigest = sha256.Sum256([]byte(message))
			message = string(ReduceSHA256Hash(hashDigest, column))
		}
		(*table)[hex.EncodeToString(hashDigest[:])] = start
	}
	fmt.Printf("\tgenerated %d total rows successfully\n", rows)
}

func (table *RainbowTable) CrackSHA256Hash(targetDigest [sha256.Size]byte) ([]byte, error) {
	for startColumn := ChainLength - 1; startColumn >= 0; startColumn-- {

		candidate := targetDigest

		for column := startColumn; column < ChainLength-1; column++ {
			candidate = sha256.Sum256(ReduceSHA256Hash(candidate, column))
		}

		if start, ok := (*table)[hex.EncodeToString(candidate[:])]; ok {

			message, err := traverseChain(targetDigest, start)

			if err == nil {
				fmt.Printf("\tstart: %s ... (%03d) message: %s -> digest: %s\n",
					start, startColumn, message, hex.EncodeToString(targetDigest[:]))
				return message, nil
			}

		}
	}

	return nil, errors.New("no hits in the table")
}

func traverseChain(originalDigest [sha256.Size]byte, start string) ([]byte, error) {
	message := start
	for column := 0; column < ChainLength; column++ {
		hashDigest := sha256.Sum256([]byte(message))
		if bytes.Equal(hashDigest[:], originalDigest[:]) {
			return []byte(message), nil
		}
		message = string(ReduceSHA256Hash(hashDigest, column))
	}
	return nil, errors.New("false alarm")
}
