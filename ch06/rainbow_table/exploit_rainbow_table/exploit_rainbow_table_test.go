package exploit_rainbow_table

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/krkhan/crypto-impl-exploit/ch06/rainbow_table/impl_rainbow_table"
)

func fileExists(filename string) bool {
	_, err := os.Stat(filename)
	if os.IsNotExist(err) {
		return false
	}
	return err == nil
}

func generateOrLoadTable() (*RainbowTable, error) {
	jsonPath := filepath.Join("testdata", "table.json")

	var table *RainbowTable
	if !fileExists(jsonPath) {
		table := make(RainbowTable)
		table.PopulateRainbowTable(5000000)
		file, err := os.Create(jsonPath)
		if err != nil {
			return nil, errors.New(fmt.Sprintf("error creating %s: %s", jsonPath, err))
		}
		defer file.Close()

		encoder := json.NewEncoder(file)
		encoder.SetIndent("", "    ")

		err = encoder.Encode(table)
		if err != nil {
			return nil, errors.New(fmt.Sprintf("error encoding json: %s", err))
		}
	} else {
		file, err := os.Open(jsonPath)
		if err != nil {
			return nil, errors.New(fmt.Sprintf("error opening file: %s", err))
		}
		defer file.Close()

		decoder := json.NewDecoder(file)
		table = &RainbowTable{}
		err = decoder.Decode(table)

		if err != nil {
			return nil, errors.New(fmt.Sprintf("error decoding json: %s", err))
		}
	}

	return table, nil
}

func TestRainbowTable(t *testing.T) {
	table, err := generateOrLoadTable()
	if err != nil {
		t.Fatal(err)
	}

	t.Logf("rainbow table contains %d rows", len(*table))

	totalUsers := 100
	usersDb := impl_rainbow_table.NewUserDatabase()
	for i := 0; i < totalUsers; i++ {
		username := fmt.Sprintf("user-%03d", i)
		usersDb.RegisterUserWithRandomPassword(username)
	}

	startTime := time.Now()

	successfulCracks := 0
	for username, passwordHashHex := range usersDb.Hashes {
		passwordHash, _ := hex.DecodeString(passwordHashHex)
		var passwordHash256 [sha256.Size]byte
		copy(passwordHash256[:], passwordHash)
		password, err := table.CrackSHA256Hash(passwordHash256)
		if err == nil {
			if usersDb.AuthenticateUser(username, string(password)) {
				successfulCracks++
			}
		}
	}

	endTime := time.Now()
	deltaTime := endTime.Sub(startTime)

	t.Logf("%d/%d hashes cracked successfully in %.2f seconds", successfulCracks, totalUsers, deltaTime.Seconds())
	if float32(successfulCracks) < float32(totalUsers)*0.1 {
		t.Fatal("rainbow table success rate was <10%")
	}
}
