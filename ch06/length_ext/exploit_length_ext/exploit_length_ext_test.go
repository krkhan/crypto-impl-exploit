package exploit_length_ext

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strconv"
	"testing"
	"time"

	"github.com/krkhan/crypto-impl-exploit/ch06/length_ext/impl_length_ext"
)

func TestExtendSha256(t *testing.T) {
	originalMsg := []byte("01234567890abcdef01234567890abcdef01234567890abcdef01234567890abcdef")
	maliciousData := []byte("01234567890abcdef01234567890abcdef01234567890abcdef0123")

	hasher := sha256.New()
	hasher.Write(originalMsg)
	originalDigest := hasher.Sum(nil)
	t.Logf("originalDigest: %s", hex.EncodeToString(originalDigest))

	padding := generatePadding(uint64(len(originalMsg)))
	t.Logf("padding: %s", hex.EncodeToString(padding))
	hasher.Write(padding)

	hasher.Write(maliciousData)
	expectedDigest := hasher.Sum(nil)
	t.Logf("expectedDigest: %s", hex.EncodeToString(expectedDigest))

	extendedDigest, err := ExtendSha256(uint64(len(originalMsg)), originalDigest, maliciousData)
	if err != nil {
		t.Fatalf("error extending digest: %s", err)
	}

	t.Logf("extendedDigest: %s", hex.EncodeToString(extendedDigest))

	if !bytes.Equal(expectedDigest, extendedDigest) {
		t.Fatalf("expected and extended digests mismatch")
	}
}

func TestExtendHttpRequestMac(t *testing.T) {
	b := impl_length_ext.NewBank()
	req, err := b.CreateClientAndGenerateSignedTransaction()
	if err != nil {
		t.Fatalf("error generating signed request: %s", err)
	}
	t.Logf("good request url: %s", req.URL)

	originalReqTs, _ := strconv.ParseInt(req.URL.Query().Get("ts"), 10, 64)

	time.Sleep(2 * time.Second)

	maliciousReqTs := time.Now().UnixMicro()

	maliciousParams := map[string]string{
		"clientId": req.URL.Query().Get("clientId"),
		"amount":   strconv.FormatInt(424242, 10),
		"ts":       strconv.FormatInt(maliciousReqTs, 10),
	}
	err = ExtendHttpRequestMac(req, maliciousParams)
	if err != nil {
		t.Fatalf("error extending mac: %s", err)
	}

	t.Logf("malicious request url: %s", req.URL)

	w := httptest.NewRecorder()
	b.TransactionHttpHandler(w, req)
	res := w.Result()

	t.Logf("response status: %s", res.Status)

	if res.StatusCode != http.StatusOK {
		var errorResponse map[string]string
		json.NewDecoder(res.Body).Decode(&errorResponse)
		t.Fatalf("error: %s", errorResponse["errmsg"])
	}

	var transactionResponse map[string]string
	json.NewDecoder(res.Body).Decode(&transactionResponse)
	t.Logf("old balance: %s", transactionResponse["oldBalance"])
	t.Logf("new balance: %s", transactionResponse["newBalance"])
	t.Logf("malicious request was sent %d Âµs after the original good request", maliciousReqTs-originalReqTs)
}
