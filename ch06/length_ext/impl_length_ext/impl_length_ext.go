package impl_length_ext

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"math/rand"
	"net/http"
	"net/http/httptest"
	"net/url"
	"os"
	"sort"
	"strconv"
	"time"
)

const ClientSecretLength = 16

type Bank struct {
	clientNames    map[uint32]string
	clientSecrets  map[uint32]string
	clientBalances map[uint32]int64
}

func NewBank() *Bank {
	return &Bank{
		clientNames:    make(map[uint32]string),
		clientSecrets:  make(map[uint32]string),
		clientBalances: make(map[uint32]int64),
	}
}

func (b *Bank) generateClientId() uint32 {
	for {
		newClientId := rand.Uint32()
		if _, ok := b.clientNames[newClientId]; !ok {
			return newClientId
		}
	}
}

func calculateMac(clientSecret string, queryParams map[string]string, verbose bool) string {
	var keys []string
	for k := range queryParams {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	hasher := sha256.New()
	hasher.Write([]byte(clientSecret))
	if verbose {
		fmt.Print("\thash input: <REDACTED_SECRET>")
	}
	for _, k := range keys {
		if k == "mac" {
			continue
		}
		v := queryParams[k]
		if verbose {
			fmt.Printf("|%s|%s", k, url.QueryEscape(v))
		}
		hasher.Write([]byte(k))
		hasher.Write([]byte(v))
	}
	digest := hex.EncodeToString(hasher.Sum(nil))
	if verbose {
		fmt.Printf("\n\thash output: %s\n", digest)
	}
	return hex.EncodeToString(hasher.Sum(nil))
}

func (b *Bank) authenticateRequest(r *http.Request) (uint32, error) {
	clientId, err := strconv.ParseUint(r.URL.Query().Get("clientId"), 10, 32)
	if err != nil {
		return 0, errors.New("invalid client id")
	}
	clientId32 := uint32(clientId)

	clientSecret, ok := b.clientSecrets[clientId32]
	if !ok {
		return 0, errors.New("client not found")
	}

	queryParams := make(map[string]string)
	for k, v := range r.URL.Query() {
		queryParams[k] = v[0]
	}

	expected := calculateMac(clientSecret, queryParams, true)
	if r.URL.Query().Get("mac") != expected {
		return 0, errors.New("invalid mac")
	}

	reqTime, err := strconv.ParseInt(r.URL.Query().Get("ts"), 10, 64)
	if err != nil {
		return 0, errors.New("timestamp not found")
	}

	currentTime := time.Now().UnixMicro()
	if currentTime < reqTime || currentTime-reqTime > 1000 {
		return 0, errors.New(fmt.Sprintf("invalid timestamp, currentTime: %d, reqSignedTime: %d, delta: %d (µs)",
			reqTime,
			currentTime,
			currentTime-reqTime))
	}

	fmt.Printf("\trequest authenticated successfully, requestTime: %d, currentTime: %d, delta: %d (µs)\n",
		reqTime,
		currentTime,
		currentTime-reqTime)

	return clientId32, nil
}

func generateRandomHexString(byteLen int) string {
	buffer := make([]byte, byteLen)
	_, err := rand.Read(buffer)
	if err != nil {
		fmt.Printf("cannot get random bytes: %s\n", err)
		os.Exit(1)
	}
	return hex.EncodeToString(buffer)
}

func (b *Bank) NewClientHttpHandler(w http.ResponseWriter, r *http.Request) {
	clientName := r.URL.Query().Get("clientName")
	clientSecret := generateRandomHexString(ClientSecretLength)
	clientId := b.generateClientId()

	b.clientNames[clientId] = clientName
	b.clientSecrets[clientId] = clientSecret
	b.clientBalances[clientId] = 0

	response := map[string]string{
		"clientId":     strconv.FormatUint(uint64(clientId), 10),
		"clientSecret": clientSecret,
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

func (b *Bank) NewClient(
	clientName string) (
	httpReq *http.Request,
	clientId string,
	clientSecret string, err error) {
	httpReq = httptest.NewRequest(http.MethodGet, fmt.Sprintf("/new-client?clientName=%s", clientName), nil)
	w := httptest.NewRecorder()
	b.NewClientHttpHandler(w, httpReq)
	res := w.Result()
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		var errorResponse map[string]string
		json.NewDecoder(res.Body).Decode(&errorResponse)
		err = errors.New(errorResponse["errmsg"])
		return
	}

	var newClientResponse map[string]string
	err = json.NewDecoder(res.Body).Decode(&newClientResponse)
	if err != nil {
		return
	}
	clientId = newClientResponse["clientId"]
	clientSecret = newClientResponse["clientSecret"]
}

func (b *Bank) CheckBalanceHttpHandler(w http.ResponseWriter, r *http.Request) {
	clientId, err := b.authenticateRequest(r)
	if err != nil {
		w.WriteHeader(http.StatusForbidden)
		response := map[string]string{
			"errmsg": err.Error(),
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	response := map[string]string{
		"balance": strconv.FormatInt(b.clientBalances[clientId], 10),
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

func (b *Bank) CheckBalance(
	clientId string,
	clientSecret string) (
	httpReq *http.Request,
	currentBalance string,
	err error) {
	queryParams := map[string]string{
		"clientId": clientId,
		"ts":       strconv.FormatInt(time.Now().UnixMicro(), 10),
	}
	mac := calculateMac(clientSecret, queryParams, false)
	httpReq = httptest.NewRequest(http.MethodGet,
		fmt.Sprintf("/balance?clientId=%s&ts=%s&mac=%s",
			queryParams["clientId"],
			queryParams["ts"],
			mac), nil)
	w := httptest.NewRecorder()
	b.CheckBalanceHttpHandler(w, httpReq)
	res := w.Result()
	defer res.Body.Close()
	if res.StatusCode != http.StatusOK {
		var errorResponse map[string]string
		json.NewDecoder(res.Body).Decode(&errorResponse)
		err = errors.New(errorResponse["errmsg"])
		return
	}

	var checkBalanceResponse map[string]string
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(body, &checkBalanceResponse)
	if err != nil {
		return
	}
	currentBalance = checkBalanceResponse["balance"]
	return
}

func (b *Bank) TransactionHttpHandler(w http.ResponseWriter, r *http.Request) {
	clientId, err := b.authenticateRequest(r)
	if err != nil {
		w.WriteHeader(http.StatusForbidden)
		response := map[string]string{
			"errmsg": err.Error(),
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	transactionAmount, err := strconv.ParseInt(r.URL.Query().Get("amount"), 10, 64)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		response := map[string]string{
			"errmsg": "invalid transaction amount",
		}
		json.NewEncoder(w).Encode(response)
		return
	}

	oldBalance := b.clientBalances[clientId]
	b.clientBalances[clientId] += transactionAmount
	newBalance := b.clientBalances[clientId]

	response := map[string]string{
		"oldBalance": strconv.FormatInt(oldBalance, 10),
		"newBalance": strconv.FormatInt(newBalance, 10),
	}
	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(response)
}

func (b *Bank) Transaction(
	clientId string,
	clientSecret string,
	amount int64) (
	httpReq *http.Request,
	oldBalance string,
	newBalance string,
	err error) {
	queryParams := map[string]string{
		"amount":   strconv.FormatInt(amount, 10),
		"clientId": clientId,
		"ts":       strconv.FormatInt(time.Now().UnixMicro(), 10),
	}
	mac := calculateMac(clientSecret, queryParams, false)
	httpReq = httptest.NewRequest(http.MethodGet,
		fmt.Sprintf("/transaction?clientId=%s&amount=%s&ts=%s&mac=%s",
			queryParams["clientId"],
			queryParams["amount"],
			queryParams["ts"],
			mac), nil)
	w := httptest.NewRecorder()
	b.TransactionHttpHandler(w, httpReq)
	res := w.Result()
	defer res.Body.Close()
	if res.StatusCode != http.StatusOK {
		var errorResponse map[string]string
		json.NewDecoder(res.Body).Decode(&errorResponse)
		err = errors.New(errorResponse["errmsg"])
		return
	}

	var transactionResponse map[string]string
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return
	}
	err = json.Unmarshal(body, &transactionResponse)
	if err != nil {
		return
	}
	oldBalance = transactionResponse["oldBalance"]
	newBalance = transactionResponse["newBalance"]
	return
}

func (b *Bank) CreateClientAndGenerateSignedTransaction() (*http.Request, error) {
	_, clientId, clientSecret, err := b.NewClient(generateRandomHexString(8))
	if err != nil {
		return nil, err
	}
	req, _, _, err := b.Transaction(clientId, clientSecret, 10)
	if err != nil {
		return nil, err
	}
	return req, nil
}
